/**
 Напишите функцию throttle(f, ms) — «тормозилку», которая возвращает обёртку, передающую вызов f не чаще,
 чем раз в ms миллисекунд.
 У этой функции должно быть важное существенное отличие от debounce: если игнорируемый вызов оказался последним,
 т.е. после него до окончания задержки ничего нет — то он выполнится.
 Чтобы лучше понять, откуда взялось это требование, и как throttle должна работать — разберём реальное применение,
 на которое и ориентирована эта задача.
 Например, нужно обрабатывать передвижения мыши.
 В JavaScript это делается функцией, которая будет запускаться при каждом микро-передвижении мыши и получать
 координаты курсора. По мере того, как мышь двигается, эта функция может запускаться очень часто, может быть
 100 раз в секунду (каждые 10мс).
 Функция обработки передвижения должна обновлять некую информацию на странице.
 При этом обновление — слишком «тяжёлый» процесс, чтобы делать его при каждом микро-передвижении. Имеет смысл
 делать его раз в 100мс, не чаще.
 Пусть функция, которая осуществляет это обновление по передвижению, называется onmousemove.
 Вызов throttle(onmousemove, 100), по сути, предназначен для того, чтобы «притормаживать» обработку onmousemove.
 Технически, он должен возвращать обёртку, которая передаёт все вызовы onmousemove, но не чаще чем раз в 100мс.
 При этом промежуточные движения можно игнорировать, но мышь в конце концов где-то остановится. И это последнее,
 итоговое положение мыши обязательно нужно обработать!
 Визуально это даст следующую картину обработки перемещений мыши:
 Первое обновление произойдёт сразу (это важно, посетитель тут же видит реакцию на своё действие).
 Дальше может быть много вызовов (микро-передвижений) с разными координатами, но пока не пройдёт 100мс — ничего не будет.
 По истечении 100мс — опять обновление, с последними координатами. Промежуточные микро-передвижения игнорированы.
 В конце концов мышь где-то остановится, обновление по окончании очередной паузы 100мс сработает с последними координатами.
 Ещё раз заметим — задача из реальной жизни, и в ней принципиально важно, что последнее передвижение обрабатывается.
 Пользователь должен увидеть, где остановил мышь.

 Шаги работы этой функции:
 Декоратор throttle возвращает функцию-обёртку wrapper, которая при первом вызове запускает func и переходит в
 состояние «паузы» (isThrottled = true).
 В этом состоянии все новые вызовы запоминаются в замыкании через savedArgs/savedThis. Обратим внимание, что и
 контекст вызова и аргументы для нас одинаково важны и запоминаются одновременно. Только зная и то и другое,
 можно воспроизвести вызов правильно.
 Далее, когда пройдёт таймаут ms миллисекунд — пауза будет снята, а wrapper — запущен с последними аргументами и
 контекстом (если во время паузы были вызовы).
 Шаг (3) запускает именно не саму функцию, а снова wrapper, так как необходимо не только выполнить func, но и снова
 поставить выполнение на паузу. Получается последовательность «вызов – пауза.. вызов – пауза .. вызов – пауза …",
 каждое выполнение в обязательном порядке сопровождается паузой после него. Это удобно описывается рекурсией.
 */

function throttle(func, ms) {
    var isThrottled = false, savedArgs, savedThis;
    function wrapper() {
        if (isThrottled) { // (2)
            savedArgs = arguments;
            savedThis = this;
            return;
        }
        func.apply(this, arguments); // (1)
        isThrottled = true;
        setTimeout(function() {
            isThrottled = false; // (3)
            if (savedArgs) {
                wrapper.apply(savedThis, savedArgs);
                savedArgs = savedThis = null;
            }
        }, ms);
    }
    return wrapper;
}

